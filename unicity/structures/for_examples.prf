(for_examples
 (expit_test 0
  (expit_test-1 nil 3505593379 ("" (grind) nil nil)
   ((for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (expit const-decl "real" for_examples nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak))
 (expit_sound_TCC1 0
  (expit_sound_TCC1-1 nil 3508441056 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (expit_sound 0
  (expit_sound-1 nil 3508441066
   ("" (skeep)
    (("" (expand "expit")
      (("" (lemma "for_induction[real]")
        (("" (inst?)
          (("" (inst -1 "LAMBDA(i:upto(n),a:real): a = x^i")
            (("" (rewrite "expt_x0")
              (("" (assert)
                (("" (hide 2)
                  (("" (skeep)
                    (("" (case-replace "x=0")
                      (("1" (grind) nil nil)
                       ("2" (rewrite "expt_plus")
                        (("2" (rewrite "expt_x1")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((expit const-decl "real" for_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (ForBody type-eq-decl nil for_iterate nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (expt def-decl "real" exponentiation nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (for_induction formula-decl nil for_iterate nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   shostak))
 (factit_test 0
  (factit_test-1 nil 3505593275 ("" (grind) nil nil)
   ((nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (factit const-decl "nat" for_examples nil)
    (for_down const-decl "T" for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil))
   shostak))
 (factit_sound 0
  (factit_sound-1 nil 3508421087
   ("" (skeep)
    (("" (expand "factit")
      (("" (lemma "for_down_induction[nat]")
        (("" (inst? -1)
          ((""
            (inst -1
             "LAMBDA(i:upto(n),a:nat): a = factorial(n)/factorial(n-i)")
            (("" (assert)
              (("" (hide 2)
                (("" (skeep)
                  (("" (expand "factorial" -1 2)
                    (("" (grind-reals) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((factit const-decl "nat" for_examples nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (ForBody type-eq-decl nil for_iterate nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (factorial_0 formula-decl nil factorial "ints/")
    (div_cancel4 formula-decl nil real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (factorial def-decl "posnat" factorial "ints/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (for_down_induction formula-decl nil for_iterate nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak))
 (maxit_TCC1 0
  (maxit_TCC1-1 nil 3505593581 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil))
   nil))
 (maxit_TCC2 0
  (maxit_TCC2-1 nil 3508362429 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (maxit_test 0
  (maxit_test-1 nil 3505593776 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (iterate_left const-decl "T" for_iterate nil)
    (maxit const-decl "real" for_examples nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (maxit_sound 0
  (maxit_sound-1 nil 3508424536
   ("" (skeep)
    (("" (expand "maxit")
      (("" (lemma "iterate_left_induction[real]")
        (("" (inst? -1)
          (("1"
            (inst -1
             "LAMBDA(n:below(length(l)),a:real):FORALL(k:upto(n)):nth(l,k) <= a")
            (("1" (split -1)
              (("1" (inst -1 "i") nil nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil)
               ("3" (hide 2)
                (("3" (skosimp*)
                  (("3" (rewrite "le_max")
                    (("3" (flatten)
                      (("3" (inst? -1) (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (skosimp) (("2" (ground) nil nil)) nil)) nil))
            nil)
           ("2" (hide 2) (("2" (skosimp) (("2" (ground) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((maxit const-decl "real" for_examples nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (l skolem-const-decl "(cons?[real])" for_examples nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (< const-decl "bool" reals nil)
    (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (subrange type-eq-decl nil integers nil)
    (IterateBody type-eq-decl nil for_iterate nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (k!2 skolem-const-decl "upto(1 + k!1)" for_examples nil)
    (k!1 skolem-const-decl "below(length(l) - 1)" for_examples nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (le_max formula-decl nil real_defs nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (iterate_left_induction formula-decl nil for_iterate nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   shostak))
 (minit_test 0
  (minit_test-1 nil 3508284859 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (for_down const-decl "T" for_iterate nil)
    (iterate_right const-decl "T" for_iterate nil)
    (minit const-decl "real" for_examples nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (minit_sound 0
  (minit_sound-1 nil 3508461473
   ("" (skeep)
    (("" (expand "minit")
      (("" (lemma "iterate_right_induction[real]")
        (("" (inst?)
          (("1"
            (inst -1
             "LAMBDA(n:below(length(l)),a:real): LET ll = length(l)-1 IN FORALL(k:subrange(ll-n,ll)) :a <= nth(l,k)")
            (("1" (assert)
              (("1" (split)
                (("1" (inst? -1) nil nil)
                 ("2" (hide 2)
                  (("2" (skosimp* :preds? t)
                    (("2" (rewrite "min_le")
                      (("2" (flatten)
                        (("2" (inst?) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (skosimp) (("2" (ground) nil nil)) nil)) nil)
             ("3" (hide 2)
              (("3" (skosimp*) (("3" (ground) nil nil)) nil)) nil))
            nil)
           ("2" (hide 2)
            (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((minit const-decl "real" for_examples nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (l skolem-const-decl "(cons?[real])" for_examples nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (< const-decl "bool" reals nil)
    (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (subrange type-eq-decl nil integers nil)
    (IterateBody type-eq-decl nil for_iterate nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min_le formula-decl nil real_defs nil)
    (k!1 skolem-const-decl "below(length(l) - 1)" for_examples nil)
    (k!2 skolem-const-decl
     "subrange(length(l) - 2 - k!1, length(l) - 1)" for_examples nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (iterate_right_induction formula-decl nil for_iterate nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   shostak)))

