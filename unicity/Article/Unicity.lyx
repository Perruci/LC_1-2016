#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Formalização de Unicidade de Respostas para Algoritmos de Ordenação
\end_layout

\begin_layout Author
Logica Computacional 117366 
\begin_inset Newline newline
\end_inset

Turma D
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Lucas M.
 Chagas (12/0126643) e Pedro Henrique S.
 Perruci (14/0158596)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Section*
Introdução
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
paragraph{}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ao longo do estudo das Estruturas de Dados, percebe-se que os 
\emph on
Algorítimos de Ordenação
\emph default
 têm importância fundamental na eficiência de processos.
 Alguns exemplos de métodos fundamentados em estruturas ordenadas, podemos
 citar a busca binária e algorítimos de união de listas.
 Como consequência de seus benefícios, métodos de ordenação são implementadas
 para as mais diversas estruturas de dados.
\end_layout

\begin_layout Standard
Sob o viés da lógica computacional, é essêncial garantir a unicidade de
 resultados dos métodos de ordenação.
 Dessa forma, pode-se provar que, para as mesmas entradas, uma mesma estrutura
 ordenada será obtida – independentemente do algorítimo escolhido.
 Támbem é coerente investigar que estruturas diferentes, portando os mesmos
 elementos, resultarão em estruturas ordenadas equivalentes.
\end_layout

\begin_layout Standard
O objetivo deste trabalho é justamente demonstrar a unicidade de respostas
 para os algorítimos de ordenação, implementados em listas e sequêcias finitas.
 Foram designados os métodos Quicksort
\emph on
 
\emph default
e Bubble Sort
\emph on
 
\emph default
voltados para o tipo abstrato 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{list}
\end_layout

\end_inset

, Heapsort
\emph on
 
\emph default
e Maxsort
\emph on
 
\emph default
para o tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{finite
\backslash
_sequences}
\end_layout

\end_inset

.
 Como ferramenta, foi utilizado o assistente de provas PVS, associado às
 bibliotecas PVS de NASA Langley Research Center.
\end_layout

\begin_layout Section
Questão 1
\end_layout

\begin_layout Subsection
Especificação do Problema
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
paragraph{}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A primeira questão do projeto consiste em demonstrar que o primeiro elemento
 de listas ordenadas é mínimo.
 Sua conjectura encontra-se expressa abaixo.
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
min_is_sorted:
\end_layout

\begin_layout Plain Layout
|— — — — —
\end_layout

\begin_layout Plain Layout
[1] FORALL (l:list[nat], k : below[length(l)]) :
\begin_inset Newline newline
\end_inset

 is_sorted?(l) => null?(l) OR nth(l,0) <= nth(l,k)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Conjectura da Questão 1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solução Proposta
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
placement p
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Solutions/unicity_min_is_sorted.ps
	width 100text%
	height 100theight%
	rotateAngle 90

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Árvore e prova referente à Question 2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Questão 2
\end_layout

\begin_layout Subsection
Especificação do Problema
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
func_eqQB:
\end_layout

\begin_layout Plain Layout
|— — — — —
\end_layout

\begin_layout Plain Layout
[1] FORALL (l: list[nat]): quick_sort(l) = bubblesort(l)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Conjectura da Questão 2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solução Proposta
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
paragraph{}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nesta questão, provamos que quick_sort e bubblesort são funcionalmente equivalen
tes, utilizando os principais resultados da unicidade.Para formalizar, usamos
 os lemas "quick_sort_works", "bubblesort_works" e "unicity_sorted
\backslash
_lists".
 Instanciamos na fórmula -1 quick_sort(l) e bubblesort(l) para verificar
 a permutação entre quick_sort(l) e bubblesort(l) e verificar se as listas
 são sorteadas.
\end_layout

\begin_layout Standard
Primeiramente, dividimos a conjunção em 4 subárvores.
 3 dos 4 itens são triviais.
 No caso onde não é trivial, tivemos que provar que as permutações de l,
 bubblesort(l) e quick_sort(l), l são transitivas.
 
\end_layout

\begin_layout Standard
Para provar isso, tivemos que chamar o lemma "permutations_is_transitive".
\end_layout

\begin_layout Standard
Instanciamos na fórmula -1 quick
\backslash
_sort(l), l e bubblesort(l), onde chegamos em três subárvores, todas sendo
 trivias, completando a prova.
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
placement p
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Solutions/unicity_func_eqQB.ps
	width 100text%
	height 100theight%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Árvore e prova referente à Question 2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Questão 3
\end_layout

\begin_layout Subsection
Especificação do Problema
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
func_eqMH : 
\end_layout

\begin_layout Plain Layout
|— — — — —
\end_layout

\begin_layout Plain Layout
[1] FORALL (s: finite_sequence[nat]): maxsort(s) = heapsort(s)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Conjectura da Questão 3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solução Proposta
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
paragraph{}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na questão 3, assim como na questão 2, provamos que maxsort e heapsort são
 funcionalmente equivalentes, utilizando os principais resultados da unicidade
 Para formalizar, usamos os lemas "maxsort_works", "heapsort_works" e "unicity_s
orted_seqs".
 Instanciamos na fórmula -1 maxsort(s) e heapsort(s) para verificar a permutação
 entre maxsort(s) e heapsort(s) e verificar se as listas são sorteadas.
 Primeiramente, dividimos a conjunção em 4 subárvores.
 3 dos 4 itens são triviais.
 No caso onde não é trivial, tivemos que provar que as permutações de s,
 maxsort(s) e s, heapsort(s) são transitivas e que a permutação(s, maxsort(s))
 e permutação (maxsort(s),s) é simétrico.
 
\end_layout

\begin_layout Standard
Para provar isso, tivemos que chamar o lemma "permutations
\backslash
_equiv".
\end_layout

\begin_layout Standard
Tivemos que expandir a fórmula de symmetric para verificar a simetria da
 permutação s, maxsort(s).
 Obtemos, assim, a simetria da permutação(s, maxsort(s)) e permutação(maxsort(s)
, s) .
\end_layout

\begin_layout Standard
Também expandimos a fórmula de transitive para verificar a transitividade
 entre a permutação(maxsort(s), s) e permutação (s, heapsort(s)).
\backslash

\backslash
 Com a expansão, dividimos a conjunção e assim chegamos na conclusão da
 prova.
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
placement p
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Solutions/unicity_func_eqMH.ps
	width 100text%
	height 100theight%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Árvore e prova referente à Question 3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Questão 4
\end_layout

\begin_layout Subsection
Especificação do Problema
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
paragraph{}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questão pedia para provarmos que a unicidade entre as funções quick_sort
 e maxsort.
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
func_eqQM : 
\end_layout

\begin_layout Plain Layout
|— — — — —
\end_layout

\begin_layout Plain Layout
[1] FORALL (l: list[nat], s: finite_sequence[nat]):
\end_layout

\begin_layout Plain Layout
list2finseq(l)=s IMPLIES
\end_layout

\begin_layout Plain Layout
list2finseq[nat](quick_sort(l)) = maxsort(s)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Conjectura da Questão 4
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solução Proposta
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
paragraph{}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
placement p
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Solutions/unicity_func_eqQM.ps
	width 100text%
	height 100theight%
	rotateOrigin leftBottom

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Árvore e prova referente à Question 4
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section*
Conclusão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
paragraph{}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
